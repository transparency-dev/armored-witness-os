steps:
  # First create a fake tag we'll use throughout the CI build process below.
  # Unfortunately, GCB has no concept of dynamically creating substitutions or
  # passing ENV vars between steps, so the best we can do is to create a file
  # containing our tag in the share workspace which other steps can inspect.
  - name: bash
    script: |
      date +'0.3.%s-incompatible' > /workspace/fake_tag
      cat /workspace/fake_tag
  ### Build the Trusted OS and upload it to GCS.
  # Build an image containing the Trusted OS artifacts with the Dockerfile.
  # This step needs to be a bash script in order to substitute fake tag into a
  # build arg.
  - name: gcr.io/cloud-builders/docker
    entrypoint: bash
    args:
      - -c
      - |
        docker build \
          --build-arg=TAMAGO_VERSION=${_TAMAGO_VERSION} \
          --build-arg=GIT_SEMVER_TAG=$(cat /workspace/fake_tag) \
          --build-arg=LOG_ORIGIN=${_ORIGIN} \
          --build-arg=LOG_PUBLIC_KEY=${_LOG_PUBLIC_KEY} \
          --build-arg=APPLET_PUBLIC_KEY=${_APPLET_PUBLIC_KEY} \
          --build-arg=OS_PUBLIC_KEY1=${_OS_PUBLIC_KEY1} \
          --build-arg=OS_PUBLIC_KEY2=${_OS_PUBLIC_KEY2} \
          --build-arg=BEE=${_BEE} \
          --build-arg=DEBUG=${_DEBUG} \
          --build-arg=SRK_HASH=${_CI_SRK_HASH} \
          -t builder-image \
          .
  # Prepare a container with a copy of the artifacts.
  - name: gcr.io/cloud-builders/docker
    args:
      - create
      - --name
      - builder_scratch
      - builder-image
  # Copy the artifacts from the container to the Cloud Build VM.
  - name: gcr.io/cloud-builders/docker
    args:
      - cp
      - builder_scratch:/build/bin
      - output
  # List the artifacts.
  - name: bash
    args:
      - ls
      - output
  # Copy the artifacts from the Cloud Build VM to GCS.
  - name: gcr.io/cloud-builders/gcloud
    entrypoint: bash
    args:
      - -c
      - |
        gcloud storage cp \
          output/trusted_os.elf \
          gs://${_FIRMWARE_BUCKET}/$(sha256sum output/trusted_os.elf | cut -f1 -d" ")
  ### Construct log entry / Claimant Model statement.
  # Create the manifest.
  # This step needs to be a bash script in order to substitute the fake tag
  # in the command args.
  - name: golang
    entrypoint: bash
    args:
      - -c
      - |
        go run github.com/transparency-dev/armored-witness/cmd/manifest@main \
          create \
          --git_tag=$(cat /workspace/fake_tag) \
          --git_commit_fingerprint=${COMMIT_SHA} \
          --firmware_file=output/trusted_os.elf \
          --firmware_type=TRUSTED_OS \
          --tamago_version=${_TAMAGO_VERSION} \
          --build_env="LOG_ORIGIN=${_ORIGIN}" \
          --build_env="LOG_PUBLIC_KEY=${_LOG_PUBLIC_KEY}" \
          --build_env="APPLET_PUBLIC_KEY=${_APPLET_PUBLIC_KEY}" \
          --build_env="OS_PUBLIC_KEY1=${_OS_PUBLIC_KEY1}" \
          --build_env="OS_PUBLIC_KEY2=${_OS_PUBLIC_KEY2}" \
          --build_env="BEE=${_BEE}" \
          --build_env="DEBUG=${_DEBUG}" \
          --build_env="SRK_HASH=${_CI_SRK_HASH}" \
          --raw \
          --output_file=output/trusted_os_manifest_unsigned.json
  # Sign the log entry.
  - name: golang
    args:
      - go
      - run
      - github.com/transparency-dev/armored-witness/cmd/sign@main
      - --project_name=${PROJECT_ID}
      - --release=ci
      - --artefact=os1
      - --manifest_file=output/trusted_os_manifest_unsigned.json
      - --output_file=output/trusted_os_manifest_transparency_dev
  # Countersign the log entry to fake a WS signature for CI
  - name: golang
    args:
      - go
      - run
      - github.com/transparency-dev/armored-witness/cmd/sign@main
      - --project_name=${PROJECT_ID}
      - --release=ci
      - --artefact=os2
      - --note_file=output/trusted_os_manifest_transparency_dev
      - --note_verifier=${_OS_PUBLIC_KEY1}
      - --output_file=output/trusted_os_manifest_both
  # Print the content of the signed manifest.
  - name: bash
    args:
      - cat
      - output/trusted_os_manifest_both
  ### Write the firmware release to the CI transparency log.
  # Copy the signed note to the sequence bucket, preparing to write to log.
  #
  # Use the SHA256 of the manifest as the name of the manifest. This allows
  # multiple triggers to run without colliding.
  - name: gcr.io/cloud-builders/gcloud
    entrypoint: bash
    args:
      - -c
      - |
        gcloud storage cp output/trusted_os_manifest_both \
        gs://${_LOG_NAME}/${_ENTRIES_DIR}/$(sha256sum output/trusted_os_manifest_both | cut -f1 -d" ")/trusted_os_manifest_both
  # Sequence log entry.
  - name: gcr.io/cloud-builders/gcloud
    entrypoint: bash
    args:
      - -c
      - >
        gcloud functions call sequence \

        --data="{
          \"entriesDir\": \"${_ENTRIES_DIR}/$(sha256sum output/trusted_os_manifest_both | cut -f1 -d" ")\",
          \"origin\": \"${_ORIGIN}\",
          \"bucket\": \"${_LOG_NAME}\",
          \"kmsKeyName\": \"ft-log-ci\",
          \"kmsKeyRing\": \"firmware-release-ci\",
          \"kmsKeyVersion\": ${_KEY_VERSION},
          \"kmsKeyLocation\": \"global\",
          \"noteKeyName\": \"transparency.dev-aw-ftlog-ci-${_KEY_VERSION}\",
          \"checkpointCacheControl\": \"${_CHECKPOINT_CACHE}\"
        }"
  # Integrate log entry.
  - name: gcr.io/cloud-builders/gcloud
    args:
      - functions
      - call
      - integrate
      - '--data'
      - >-
        {
          "origin": "${_ORIGIN}",
          "bucket": "${_LOG_NAME}",
          "kmsKeyName": "ft-log-ci",
          "kmsKeyRing": "firmware-release-ci",
          "kmsKeyVersion": ${_KEY_VERSION},
          "kmsKeyLocation": "global",
          "noteKeyName": "transparency.dev-aw-ftlog-ci-${_KEY_VERSION}",
          "checkpointCacheControl": "${_CHECKPOINT_CACHE}"
        }
  # Clean up the file we added to the _ENTRIES_DIR bucket now that it's been
  # integrated to the log.
  - name: gcr.io/cloud-builders/gcloud
    entrypoint: bash
    args:
      - -c
      - |
        gcloud storage rm \
        gs://${_LOG_NAME}/${_ENTRIES_DIR}/$(sha256sum output/trusted_os_manifest_both | cut -f1 -d" ")/trusted_os_manifest_both
substitutions:
  # Build-related.
  _FIRMWARE_BUCKET: armored-witness-firmware-ci-2
  _TAMAGO_VERSION: '1.21.5'
  # Log-related.
  _ENTRIES_DIR: firmware-log-sequence
  # This must correspond with the trailing number on the _FIRMWARE_BUCKET, _ORIGIN, _LOG_NAME values.
  _KEY_VERSION: 2
  _ORIGIN: transparency.dev/armored-witness/firmware_transparency/ci/2
  _LOG_NAME: armored-witness-firmware-log-ci-2
  _LOG_PUBLIC_KEY: transparency.dev-aw-ftlog-ci-2+f77c6276+AZXqiaARpwF4MoNOxx46kuiIRjrML0PDTm+c7BLaAMt6
  _APPLET_PUBLIC_KEY: transparency.dev-aw-applet-ci+3ff32e2c+AV1fgxtByjXuPjPfi0/7qTbEBlPGGCyxqr6ZlppoLOz3
  _OS_PUBLIC_KEY1: transparency.dev-aw-os1-ci+7a0eaef3+AcsqvmrcKIbs21H2Bm2fWb6oFWn/9MmLGNc6NLJty2eQ
  _OS_PUBLIC_KEY2: transparency.dev-aw-os2-ci+af8e4114+AbBJk5MgxRB+68KhGojhUdSt1ts5GAdRIT1Eq9zEkgQh
  _BEE: '1'
  _DEBUG: '1'
  _CHECKPOINT_CACHE: 'public, max-age=30'
  # Pinned CI SRK hash
  # This MUST be identical to the _PINNED_SRK_HASH in https://github.com/transparency-dev/armored-witness-boot/blob/main/release/cloudbuild_ci.yaml#L223-L224
  # and MUST NOT be changed unless you know very well what you're doing, otherwise devices will be bricked!
  _CI_SRK_HASH: 'b8ba457320663bf006accd3c57e06720e63b21ce5351cb91b4650690bb08d85a'
